\section{Related Work}

A vast majority of work in the literature has used either tokens or abstract syntax trees as input representations of code (see \cite{Allamanis:2018:SML:3236632.3212695} for a comprehensive survey on the topic).  When these input code representations are used for a specific application, the target is usually a distributed representation of code (see again \cite{Allamanis:2018:SML:3236632.3212695} for an excellent breakdown of prior work in Table 2), with a few that build various types of probabilistic graphical models from code.  A few papers have used data and control flow based representations of code as input to drive various applications.  As an example, \cite{DBLP:conf/icpp/HsiaoCN14} used a program dependence graph to detect code duplication on Javascript programs, but the dependence is computed in an intra-procedural manner.  Similarly, \cite{DBLP:conf/iclr/AllamanisBK18} augments an AST based representation of code along with local data flow and control flow edges to predict variable names or find the misuse of variables in code.  \cite{DBLP:journals/corr/abs-1811-01824} combines token based representations of code with edges based on object uses, and AST nodes to predict the documentation of a method.  \cite{Chae:2017:AGF:3152284.3133925} uses C-reduce, which takes a C file, and a specific property of interest (e.g. an assertion about values of a particular variable in a program), and builds an abstract data flow over this reduced C program to understand what sort of data flow patterns require expensive static analysis techniques such as flow sensitivity. \cite{Bruch:2009:LEI:1595696.1595728, Proksch:2015:ICC:2852270.2744200} includes partial object use information from WALA for code completion tasks, but the primary abstraction in that work is (a) a vector representation of APIs for Java SWT, that they used in machine learning algorithms such as best matching neighbors to find the next best API for completion \cite{Bruch:2009:LEI:1595696.1595728}, or (b) as a Bayesian network which reflects the likelihood of a specific method call given the other method calls that have been observed \cite{Proksch:2015:ICC:2852270.2744200}. \cite{Nguyen:2015:GSL:2818754.2818858, Nguyen:2009:GMM:1595696.1595767} employs a mostly intraprocedural (with heuristics for handling interprocedural analysis) to mine a large number of graphs augmented with control and data flow, for the purposes of code completion for Java API calls.  This work is interesting because, like us, \cite{Nguyen:2015:GSL:2818754.2818858} it creates a large program graph database which models dependencies between parent and child graphs, from which a Bayesian model is constructed to predict the next set of API calls based on the current one.  Our work can be distinguished from prior work in this area in two key ways: (a) our work targets interprocedural data and control flow, in the presence of first class functions and no typing, to create a more comprehensive representation of code, and (b) we use this representation to drive the construction of a \textit{multi-purpose} knowledge graph of data science code.
